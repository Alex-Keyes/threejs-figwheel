var THREE = {REVISION: "79"};
"function" == typeof define && define.amd ? define("three", THREE) : "undefined" != typeof exports && "undefined" != typeof module && (module.exports = THREE), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Math.sign && (Math.sign = function (x) {
    return x < 0 ? -1 : x > 0 ? 1 : +x
}), void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
    get: function () {
        return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1]
    }
}), void 0 === Object.assign && function () {
    Object.assign = function (target) {
        "use strict";
        if (void 0 === target || null === target) throw new TypeError("Cannot convert undefined or null to object");
        for (var output = Object(target), index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (void 0 !== source && null !== source) for (var nextKey in source) Object.prototype.hasOwnProperty.call(source, nextKey) && (output[nextKey] = source[nextKey])
        }
        return output
    }
}(), Object.assign(THREE, {
    MOUSE: {LEFT: 0, MIDDLE: 1, RIGHT: 2},
    CullFaceNone: 0,
    CullFaceBack: 1,
    CullFaceFront: 2,
    CullFaceFrontBack: 3,
    FrontFaceDirectionCW: 0,
    FrontFaceDirectionCCW: 1,
    BasicShadowMap: 0,
    PCFShadowMap: 1,
    PCFSoftShadowMap: 2,
    FrontSide: 0,
    BackSide: 1,
    DoubleSide: 2,
    FlatShading: 1,
    SmoothShading: 2,
    NoColors: 0,
    FaceColors: 1,
    VertexColors: 2,
    NoBlending: 0,
    NormalBlending: 1,
    AdditiveBlending: 2,
    SubtractiveBlending: 3,
    MultiplyBlending: 4,
    CustomBlending: 5,
    AddEquation: 100,
    SubtractEquation: 101,
    ReverseSubtractEquation: 102,
    MinEquation: 103,
    MaxEquation: 104,
    ZeroFactor: 200,
    OneFactor: 201,
    SrcColorFactor: 202,
    OneMinusSrcColorFactor: 203,
    SrcAlphaFactor: 204,
    OneMinusSrcAlphaFactor: 205,
    DstAlphaFactor: 206,
    OneMinusDstAlphaFactor: 207,
    DstColorFactor: 208,
    OneMinusDstColorFactor: 209,
    SrcAlphaSaturateFactor: 210,
    NeverDepth: 0,
    AlwaysDepth: 1,
    LessDepth: 2,
    LessEqualDepth: 3,
    EqualDepth: 4,
    GreaterEqualDepth: 5,
    GreaterDepth: 6,
    NotEqualDepth: 7,
    MultiplyOperation: 0,
    MixOperation: 1,
    AddOperation: 2,
    NoToneMapping: 0,
    LinearToneMapping: 1,
    ReinhardToneMapping: 2,
    Uncharted2ToneMapping: 3,
    CineonToneMapping: 4,
    UVMapping: 300,
    CubeReflectionMapping: 301,
    CubeRefractionMapping: 302,
    EquirectangularReflectionMapping: 303,
    EquirectangularRefractionMapping: 304,
    SphericalReflectionMapping: 305,
    CubeUVReflectionMapping: 306,
    CubeUVRefractionMapping: 307,
    RepeatWrapping: 1e3,
    ClampToEdgeWrapping: 1001,
    MirroredRepeatWrapping: 1002,
    NearestFilter: 1003,
    NearestMipMapNearestFilter: 1004,
    NearestMipMapLinearFilter: 1005,
    LinearFilter: 1006,
    LinearMipMapNearestFilter: 1007,
    LinearMipMapLinearFilter: 1008,
    UnsignedByteType: 1009,
    ByteType: 1010,
    ShortType: 1011,
    UnsignedShortType: 1012,
    IntType: 1013,
    UnsignedIntType: 1014,
    FloatType: 1015,
    HalfFloatType: 1025,
    UnsignedShort4444Type: 1016,
    UnsignedShort5551Type: 1017,
    UnsignedShort565Type: 1018,
    AlphaFormat: 1019,
    RGBFormat: 1020,
    RGBAFormat: 1021,
    LuminanceFormat: 1022,
    LuminanceAlphaFormat: 1023,
    RGBEFormat: THREE.RGBAFormat,
    DepthFormat: 1026,
    RGB_S3TC_DXT1_Format: 2001,
    RGBA_S3TC_DXT1_Format: 2002,
    RGBA_S3TC_DXT3_Format: 2003,
    RGBA_S3TC_DXT5_Format: 2004,
    RGB_PVRTC_4BPPV1_Format: 2100,
    RGB_PVRTC_2BPPV1_Format: 2101,
    RGBA_PVRTC_4BPPV1_Format: 2102,
    RGBA_PVRTC_2BPPV1_Format: 2103,
    RGB_ETC1_Format: 2151,
    LoopOnce: 2200,
    LoopRepeat: 2201,
    LoopPingPong: 2202,
    InterpolateDiscrete: 2300,
    InterpolateLinear: 2301,
    InterpolateSmooth: 2302,
    ZeroCurvatureEnding: 2400,
    ZeroSlopeEnding: 2401,
    WrapAroundEnding: 2402,
    TrianglesDrawMode: 0,
    TriangleStripDrawMode: 1,
    TriangleFanDrawMode: 2,
    LinearEncoding: 3e3,
    sRGBEncoding: 3001,
    GammaEncoding: 3007,
    RGBEEncoding: 3002,
    LogLuvEncoding: 3003,
    RGBM7Encoding: 3004,
    RGBM16Encoding: 3005,
    RGBDEncoding: 3006,
    BasicDepthPacking: 3200,
    RGBADepthPacking: 3201
}), THREE.Color = function (r, g, b) {
    return void 0 === g && void 0 === b ? this.set(r) : this.setRGB(r, g, b)
}, THREE.Color.prototype = {
    constructor: THREE.Color, r: 1, g: 1, b: 1, set: function (value) {
        return value instanceof THREE.Color ? this.copy(value) : "number" == typeof value ? this.setHex(value) : "string" == typeof value && this.setStyle(value), this
    }, setScalar: function (scalar) {
        this.r = scalar, this.g = scalar, this.b = scalar
    }, setHex: function (hex) {
        return hex = Math.floor(hex), this.r = (hex >> 16 & 255) / 255, this.g = (hex >> 8 & 255) / 255, this.b = (255 & hex) / 255, this
    }, setRGB: function (r, g, b) {
        return this.r = r, this.g = g, this.b = b, this
    }, setHSL: function () {
        function hue2rgb(p, q, t) {
            return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p + 6 * (q - p) * t : t < .5 ? q : t < 2 / 3 ? p + 6 * (q - p) * (2 / 3 - t) : p
        }

        return function (h, s, l) {
            if (h = THREE.Math.euclideanModulo(h, 1), s = THREE.Math.clamp(s, 0, 1), l = THREE.Math.clamp(l, 0, 1), 0 === s) this.r = this.g = this.b = l; else {
                var p = l <= .5 ? l * (1 + s) : l + s - l * s, q = 2 * l - p;
                this.r = hue2rgb(q, p, h + 1 / 3), this.g = hue2rgb(q, p, h), this.b = hue2rgb(q, p, h - 1 / 3)
            }
            return this
        }
    }(), setStyle: function (style) {
        function handleAlpha(string) {
            void 0 !== string && parseFloat(string) < 1 && console.warn("THREE.Color: Alpha component of " + style + " will be ignored.")
        }

        var m;
        if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
            var color, name = m[1], components = m[2];
            switch (name) {
                case"rgb":
                case"rgba":
                    if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) return this.r = Math.min(255, parseInt(color[1], 10)) / 255, this.g = Math.min(255, parseInt(color[2], 10)) / 255, this.b = Math.min(255, parseInt(color[3], 10)) / 255, handleAlpha(color[5]), this;
                    if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) return this.r = Math.min(100, parseInt(color[1], 10)) / 100, this.g = Math.min(100, parseInt(color[2], 10)) / 100, this.b = Math.min(100, parseInt(color[3], 10)) / 100, handleAlpha(color[5]), this;
                    break;
                case"hsl":
                case"hsla":
                    if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        var h = parseFloat(color[1]) / 360, s = parseInt(color[2], 10) / 100,
                            l = parseInt(color[3], 10) / 100;
                        return handleAlpha(color[5]), this.setHSL(h, s, l)
                    }
            }
        } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
            var hex = m[1], size = hex.length;
            if (3 === size) return this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255, this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255, this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255, this;
            if (6 === size) return this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255, this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255, this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255, this
        }
        if (style && style.length > 0) {
            var hex = THREE.ColorKeywords[style];
            void 0 !== hex ? this.setHex(hex) : console.warn("THREE.Color: Unknown color " + style)
        }
        return this
    }, clone: function () {
        return new this.constructor(this.r, this.g, this.b)
    }, copy: function (color) {
        return this.r = color.r, this.g = color.g, this.b = color.b, this
    }, copyGammaToLinear: function (color, gammaFactor) {
        return void 0 === gammaFactor && (gammaFactor = 2), this.r = Math.pow(color.r, gammaFactor), this.g = Math.pow(color.g, gammaFactor), this.b = Math.pow(color.b, gammaFactor), this
    }, copyLinearToGamma: function (color, gammaFactor) {
        void 0 === gammaFactor && (gammaFactor = 2);
        var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        return this.r = Math.pow(color.r, safeInverse), this.g = Math.pow(color.g, safeInverse), this.b = Math.pow(color.b, safeInverse), this
    }, convertGammaToLinear: function () {
        var r = this.r, g = this.g, b = this.b;
        return this.r = r * r, this.g = g * g, this.b = b * b, this
    }, convertLinearToGamma: function () {
        return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
    }, getHex: function () {
        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
    }, getHexString: function () {
        return ("000000" + this.getHex().toString(16)).slice(-6)
    }, getHSL: function (optionalTarget) {
        var hue, saturation, hsl = optionalTarget || {h: 0, s: 0, l: 0}, r = this.r, g = this.g, b = this.b,
            max = Math.max(r, g, b), min = Math.min(r, g, b), lightness = (min + max) / 2;
        if (min === max) hue = 0, saturation = 0; else {
            var delta = max - min;
            switch (saturation = lightness <= .5 ? delta / (max + min) : delta / (2 - max - min), max) {
                case r:
                    hue = (g - b) / delta + (g < b ? 6 : 0);
                    break;
                case g:
                    hue = (b - r) / delta + 2;
                    break;
                case b:
                    hue = (r - g) / delta + 4
            }
            hue /= 6
        }
        return hsl.h = hue, hsl.s = saturation, hsl.l = lightness, hsl
    }, getStyle: function () {
        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
    }, offsetHSL: function (h, s, l) {
        var hsl = this.getHSL();
        return hsl.h += h, hsl.s += s, hsl.l += l, this.setHSL(hsl.h, hsl.s, hsl.l), this
    }, add: function (color) {
        return this.r += color.r, this.g += color.g, this.b += color.b, this
    }, addColors: function (color1, color2) {
        return this.r = color1.r + color2.r, this.g = color1.g + color2.g, this.b = color1.b + color2.b, this
    }, addScalar: function (s) {
        return this.r += s, this.g += s, this.b += s, this
    }, sub: function (color) {
        return this.r = Math.max(0, this.r - color.r), this.g = Math.max(0, this.g - color.g), this.b = Math.max(0, this.b - color.b), this
    }, multiply: function (color) {
        return this.r *= color.r, this.g *= color.g, this.b *= color.b, this
    }, multiplyScalar: function (s) {
        return this.r *= s, this.g *= s, this.b *= s, this
    }, lerp: function (color, alpha) {
        return this.r += (color.r - this.r) * alpha, this.g += (color.g - this.g) * alpha, this.b += (color.b - this.b) * alpha, this
    }, equals: function (c) {
        return c.r === this.r && c.g === this.g && c.b === this.b
    }, fromArray: function (array, offset) {
        return void 0 === offset && (offset = 0), this.r = array[offset], this.g = array[offset + 1], this.b = array[offset + 2], this
    }, toArray: function (array, offset) {
        return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this.r, array[offset + 1] = this.g, array[offset + 2] = this.b, array
    }
}, THREE.ColorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}, THREE.Quaternion = function (x, y, z, w) {
    this._x = x || 0, this._y = y || 0, this._z = z || 0, this._w = void 0 !== w ? w : 1
}, THREE.Quaternion.prototype = {
    constructor: THREE.Quaternion, get x() {
        return this._x
    }, set x(value) {
        this._x = value, this.onChangeCallback()
    }, get y() {
        return this._y
    }, set y(value) {
        this._y = value, this.onChangeCallback()
    }, get z() {
        return this._z
    }, set z(value) {
        this._z = value, this.onChangeCallback()
    }, get w() {
        return this._w
    }, set w(value) {
        this._w = value, this.onChangeCallback()
    }, set: function (x, y, z, w) {
        return this._x = x, this._y = y, this._z = z, this._w = w, this.onChangeCallback(), this
    }, clone: function () {
        return new this.constructor(this._x, this._y, this._z, this._w)
    }, copy: function (quaternion) {
        return this._x = quaternion.x, this._y = quaternion.y, this._z = quaternion.z, this._w = quaternion.w, this.onChangeCallback(), this
    }, setFromEuler: function (euler, update) {
        if (euler instanceof THREE.Euler == !1) throw new Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        var c1 = Math.cos(euler._x / 2), c2 = Math.cos(euler._y / 2), c3 = Math.cos(euler._z / 2),
            s1 = Math.sin(euler._x / 2), s2 = Math.sin(euler._y / 2), s3 = Math.sin(euler._z / 2), order = euler.order;
        return "XYZ" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3, this._y = c1 * s2 * c3 - s1 * c2 * s3, this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3) : "YXZ" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3, this._y = c1 * s2 * c3 - s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3) : "ZXY" === order ? (this._x = s1 * c2 * c3 - c1 * s2 * s3, this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3) : "ZYX" === order ? (this._x = s1 * c2 * c3 - c1 * s2 * s3, this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3) : "YZX" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3, this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3) : "XZY" === order && (this._x = s1 * c2 * c3 - c1 * s2 * s3, this._y = c1 * s2 * c3 - s1 * c2 * s3, this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3), update !== !1 && this.onChangeCallback(), this
    }, setFromAxisAngle: function (axis, angle) {
        var halfAngle = angle / 2, s = Math.sin(halfAngle);
        return this._x = axis.x * s, this._y = axis.y * s, this._z = axis.z * s, this._w = Math.cos(halfAngle), this.onChangeCallback(), this
    }, setFromRotationMatrix: function (m) {
        var s, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9],
            m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
        return trace > 0 ? (s = .5 / Math.sqrt(trace + 1), this._w = .25 / s, this._x = (m32 - m23) * s, this._y = (m13 - m31) * s, this._z = (m21 - m12) * s) : m11 > m22 && m11 > m33 ? (s = 2 * Math.sqrt(1 + m11 - m22 - m33), this._w = (m32 - m23) / s, this._x = .25 * s, this._y = (m12 + m21) / s, this._z = (m13 + m31) / s) : m22 > m33 ? (s = 2 * Math.sqrt(1 + m22 - m11 - m33), this._w = (m13 - m31) / s, this._x = (m12 + m21) / s, this._y = .25 * s, this._z = (m23 + m32) / s) : (s = 2 * Math.sqrt(1 + m33 - m11 - m22), this._w = (m21 - m12) / s, this._x = (m13 + m31) / s, this._y = (m23 + m32) / s, this._z = .25 * s), this.onChangeCallback(), this
    }, setFromUnitVectors: function () {
        var v1, r;
        return function (vFrom, vTo) {
            return void 0 === v1 && (v1 = new THREE.Vector3), r = vFrom.dot(vTo) + 1, r < 1e-6 ? (r = 0, Math.abs(vFrom.x) > Math.abs(vFrom.z) ? v1.set(-vFrom.y, vFrom.x, 0) : v1.set(0, -vFrom.z, vFrom.y)) : v1.crossVectors(vFrom, vTo), this._x = v1.x, this._y = v1.y, this._z = v1.z, this._w = r, this.normalize()
        }
    }(), inverse: function () {
        return this.conjugate().normalize()
    }, conjugate: function () {
        return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
    }, dot: function (v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w
    }, lengthSq: function () {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }, length: function () {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }, normalize: function () {
        var l = this.length();
        return 0 === l ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (l = 1 / l, this._x = this._x * l, this._y = this._y * l, this._z = this._z * l, this._w = this._w * l), this.onChangeCallback(), this
    }, multiply: function (q, p) {
        return void 0 !== p ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(q, p)) : this.multiplyQuaternions(this, q)
    }, premultiply: function (q) {
        return this.multiplyQuaternions(q, this)
    }, multiplyQuaternions: function (a, b) {
        var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w, qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        return this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby, this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz, this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx, this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz, this.onChangeCallback(), this
    }, slerp: function (qb, t) {
        if (0 === t) return this;
        if (1 === t) return this.copy(qb);
        var x = this._x, y = this._y, z = this._z, w = this._w,
            cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0 ? (this._w = -qb._w, this._x = -qb._x, this._y = -qb._y, this._z = -qb._z, cosHalfTheta = -cosHalfTheta) : this.copy(qb), cosHalfTheta >= 1) return this._w = w, this._x = x, this._y = y, this._z = z, this;
        var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
        if (Math.abs(sinHalfTheta) < .001) return this._w = .5 * (w + this._w), this._x = .5 * (x + this._x), this._y = .5 * (y + this._y), this._z = .5 * (z + this._z), this;
        var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta), ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
            ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        return this._w = w * ratioA + this._w * ratioB, this._x = x * ratioA + this._x * ratioB, this._y = y * ratioA + this._y * ratioB, this._z = z * ratioA + this._z * ratioB, this.onChangeCallback(), this
    }, equals: function (quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w
    }, fromArray: function (array, offset) {
        return void 0 === offset && (offset = 0), this._x = array[offset], this._y = array[offset + 1], this._z = array[offset + 2], this._w = array[offset + 3], this.onChangeCallback(), this
    }, toArray: function (array, offset) {
        return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this._x, array[offset + 1] = this._y, array[offset + 2] = this._z, array[offset + 3] = this._w, array
    }, onChange: function (callback) {
        return this.onChangeCallback = callback, this
    }, onChangeCallback: function () {
    }
}, Object.assign(THREE.Quaternion, {
    slerp: function (qa, qb, qm, t) {
        return qm.copy(qa).slerp(qb, t)
    }, slerpFlat: function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3],
            x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
            var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
            if (sqrSin > Number.EPSILON) {
                var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                s = Math.sin(s * len) / sin, t = Math.sin(t * len) / sin
            }
            var tDir = t * dir;
            if (x0 = x0 * s + x1 * tDir, y0 = y0 * s + y1 * tDir, z0 = z0 * s + z1 * tDir, w0 = w0 * s + w1 * tDir, s === 1 - t) {
                var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                x0 *= f, y0 *= f, z0 *= f, w0 *= f
            }
        }
        dst[dstOffset] = x0, dst[dstOffset + 1] = y0, dst[dstOffset + 2] = z0, dst[dstOffset + 3] = w0
    }
}), THREE.Vector2 = function (x, y) {
    this.x = x || 0, this.y = y || 0
}, THREE.Vector2.prototype = {
    constructor: THREE.Vector2, get width() {
        return this.x
    }, set width(value) {
        this.x = value
    }, get height() {
        return this.y
    }, set height(value) {
        this.y = value
    }, set: function (x, y) {
        return this.x = x, this.y = y, this
    }, setScalar: function (scalar) {
        return this.x = scalar, this.y = scalar, this
    }, setX: function (x) {
        return this.x = x, this
    }, setY: function (y) {
        return this.y = y, this
    }, setComponent: function (index, value) {
        switch (index) {
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            default:
                throw new Error("index is out of range: " + index)
        }
    }, getComponent: function (index) {
        switch (index) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + index)
        }
    }, clone: function () {
        return new this.constructor(this.x, this.y)
    }, copy: function (v) {
        return this.x = v.x, this.y = v.y, this
    }, add: function (v, w) {
        return void 0 !== w ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(v, w)) : (this.x += v.x, this.y += v.y, this)
    }, addScalar: function (s) {
        return this.x += s, this.y += s, this
    }, addVectors: function (a, b) {
        return this.x = a.x + b.x, this.y = a.y + b.y, this
    }, addScaledVector: function (v, s) {
        return this.x += v.x * s, this.y += v.y * s, this
    }, sub: function (v, w) {
        return void 0 !== w ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(v, w)) : (this.x -= v.x, this.y -= v.y, this)
    }, subScalar: function (s) {
        return this.x -= s, this.y -= s, this
    }, subVectors: function (a, b) {
        return this.x = a.x - b.x, this.y = a.y - b.y, this
    }, multiply: function (v) {
        return this.x *= v.x, this.y *= v.y, this
    }, multiplyScalar: function (scalar) {
        return isFinite(scalar) ? (this.x *= scalar, this.y *= scalar) : (this.x = 0, this.y = 0), this
    }, divide: function (v) {
        return this.x /= v.x, this.y /= v.y, this
    }, divideScalar: function (scalar) {
        return this.multiplyScalar(1 / scalar)
    }, min: function (v) {
        return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this
    }, max: function (v) {
        return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this
    }, clamp: function (min, max) {
        return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)), this
    }, clampScalar: function () {
        var min, max;
        return function (minVal, maxVal) {
            return void 0 === min && (min = new THREE.Vector2, max = new THREE.Vector2), min.set(minVal, minVal), max.set(maxVal, maxVal), this.clamp(min, max)
        }
    }(), clampLength: function (min, max) {
        var length = this.length();
        return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length)
    }, floor: function () {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
    }, ceil: function () {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
    }, round: function () {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
    }, roundToZero: function () {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
    }, negate: function () {
        return this.x = -this.x, this.y = -this.y, this
    }, dot: function (v) {
        return this.x * v.x + this.y * v.y
    }, lengthSq: function () {
        return this.x * this.x + this.y * this.y
    }, length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }, lengthManhattan: function () {
        return Math.abs(this.x) + Math.abs(this.y)
    }, normalize: function () {
        return this.divideScalar(this.length())
    }, angle: function () {
        var angle = Math.atan2(this.y, this.x);
        return angle < 0 && (angle += 2 * Math.PI), angle
    }, distanceTo: function (v) {
        return Math.sqrt(this.distanceToSquared(v))
    }, distanceToSquared: function (v) {
        var dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy
    }, distanceToManhattan: function (v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y)
    }, setLength: function (length) {
        return this.multiplyScalar(length / this.length())
    }, lerp: function (v, alpha) {
        return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this
    }, lerpVectors: function (v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1)
    }, equals: function (v) {
        return v.x === this.x && v.y === this.y
    }, fromArray: function (array, offset) {
        return void 0 === offset && (offset = 0), this.x = array[offset], this.y = array[offset + 1], this
    }, toArray: function (array, offset) {
        return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this.x, array[offset + 1] = this.y, array
    }, fromAttribute: function (attribute, index, offset) {
        return void 0 === offset && (offset = 0), index = index * attribute.itemSize + offset, this.x = attribute.array[index], this.y = attribute.array[index + 1], this
    }, rotateAround: function (center, angle) {
        var c = Math.cos(angle), s = Math.sin(angle), x = this.x - center.x, y = this.y - center.y;
        return this.x = x * c - y * s + center.x, this.y = x * s + y * c + center.y, this
    }
}, THREE.Vector3 = function (x, y, z) {
    this.x = x || 0, this.y = y || 0, this.z = z || 0
}, THREE.Vector3.prototype = {
    constructor: THREE.Vector3, set: function (x, y, z) {
        return this.x = x, this.y = y, this.z = z, this
    }, setScalar: function (scalar) {
        return this.x = scalar, this.y = scalar, this.z = scalar, this
    }, setX: function (x) {
        return this.x = x, this
    }, setY: function (y) {
        return this.y = y, this
    }, setZ: function (z) {
        return this.z = z, this
    }, setComponent: function (index, value) {
        switch (index) {
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            default:
                throw new Error("index is out of range: " + index)
        }
    }, getComponent: function (index) {
        switch (index) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + index)
        }
    }, clone: function () {
        return new this.constructor(this.x, this.y, this.z)
    }, copy: function (v) {
        return this.x = v.x, this.y = v.y, this.z = v.z, this
    }, add: function (v, w) {
        return void 0 !== w ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(v, w)) : (this.x += v.x, this.y += v.y, this.z += v.z, this)
    }, addScalar: function (s) {
        return this.x += s, this.y += s, this.z += s, this
    }, addVectors: function (a, b) {
        return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this
    }, addScaledVector: function (v, s) {
        return this.x += v.x * s, this.y += v.y * s, this.z += v.z * s, this
    }, sub: function (v, w) {
        return void 0 !== w ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(v, w)) : (this.x -= v.x, this.y -= v.y, this.z -= v.z, this)
    }, subScalar: function (s) {
        return this.x -= s, this.y -= s, this.z -= s, this
    }, subVectors: function (a, b) {
        return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this
    }, multiply: function (v, w) {
        return void 0 !== w ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(v, w)) : (this.x *= v.x, this.y *= v.y, this.z *= v.z, this)
    }, multiplyScalar: function (scalar) {
        return isFinite(scalar) ? (this.x *= scalar, this.y *= scalar, this.z *= scalar) : (this.x = 0, this.y = 0, this.z = 0), this
    }, multiplyVectors: function (a, b) {
        return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this
    }, applyEuler: function () {
        var quaternion;
        return function (euler) {
            return euler instanceof THREE.Euler == !1 && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), void 0 === quaternion && (quaternion = new THREE.Quaternion), this.applyQuaternion(quaternion.setFromEuler(euler))
        }
    }(), applyAxisAngle: function () {
        var quaternion;
        return function (axis, angle) {
            return void 0 === quaternion && (quaternion = new THREE.Quaternion), this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle))
        }
    }(), applyMatrix3: function (m) {
        var x = this.x, y = this.y, z = this.z, e = m.elements;
        return this.x = e[0] * x + e[3] * y + e[6] * z, this.y = e[1] * x + e[4] * y + e[7] * z, this.z = e[2] * x + e[5] * y + e[8] * z, this
    }, applyMatrix4: function (m) {
        var x = this.x, y = this.y, z = this.z, e = m.elements;
        return this.x = e[0] * x + e[4] * y + e[8] * z + e[12], this.y = e[1] * x + e[5] * y + e[9] * z + e[13], this.z = e[2] * x + e[6] * y + e[10] * z + e[14], this
    }, applyProjection: function (m) {
        var x = this.x, y = this.y, z = this.z, e = m.elements, d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        return this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d, this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d, this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d, this
    }, applyQuaternion: function (q) {
        var x = this.x, y = this.y, z = this.z, qx = q.x, qy = q.y, qz = q.z, qw = q.w, ix = qw * x + qy * z - qz * y,
            iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
        return this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy, this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz, this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx, this
    }, project: function () {
        var matrix;
        return function (camera) {
            return void 0 === matrix && (matrix = new THREE.Matrix4), matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld)), this.applyProjection(matrix)
        }
    }(), unproject: function () {
        var matrix;
        return function (camera) {
            return void 0 === matrix && (matrix = new THREE.Matrix4), matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix)), this.applyProjection(matrix)
        }
    }(), transformDirection: function (m) {
        var x = this.x, y = this.y, z = this.z, e = m.elements;
        return this.x = e[0] * x + e[4] * y + e[8] * z, this.y = e[1] * x + e[5] * y + e[9] * z, this.z = e[2] * x + e[6] * y + e[10] * z, this.normalize()
    }, divide: function (v) {
        return this.x /= v.x, this.y /= v.y, this.z /= v.z, this
    }, divideScalar: function (scalar) {
        return this.multiplyScalar(1 / scalar)
    }, min: function (v) {
        return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this.z = Math.min(this.z, v.z), this
    }, max: function (v) {
        return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this.z = Math.max(this.z, v.z), this
    }, clamp: function (min, max) {
        return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)), this.z = Math.max(min.z, Math.min(max.z, this.z)), this
    }, clampScalar: function () {
        var min, max;
        return function (minVal, maxVal) {
            return void 0 === min && (min = new THREE.Vector3, max = new THREE.Vector3), min.set(minVal, minVal, minVal), max.set(maxVal, maxVal, maxVal), this.clamp(min, max)
        }
    }(), clampLength: function (min, max) {
        var length = this.length();
        return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length)
    }, floor: function () {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
    }, ceil: function () {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
    }, round: function () {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
    }, roundToZero: function () {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
    }, negate: function () {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
    }, dot: function (v) {
        return this.x * v.x + this.y * v.y + this.z * v.z
    }, lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }, length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }, lengthManhattan: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }, normalize: function () {
        return this.divideScalar(this.length())
    }, setLength: function (length) {
        return this.multiplyScalar(length / this.length())
    }, lerp: function (v, alpha) {
        return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this.z += (v.z - this.z) * alpha, this
    }, lerpVectors: function (v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1)
    }, cross: function (v, w) {
        if (void 0 !== w) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(v, w);
        var x = this.x, y = this.y, z = this.z;
        return this.x = y * v.z - z * v.y, this.y = z * v.x - x * v.z, this.z = x * v.y - y * v.x, this
    }, crossVectors: function (a, b) {
        var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
        return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx, this
    }, projectOnVector: function (vector) {
        var scalar = vector.dot(this) / vector.lengthSq();
        return this.copy(vector).multiplyScalar(scalar)
    }, projectOnPlane: function () {
        var v1;
        return function (planeNormal) {
            return void 0 === v1 && (v1 = new THREE.Vector3), v1.copy(this).projectOnVector(planeNormal), this.sub(v1)
        }
    }(), reflect: function () {
        var v1;
        return function (normal) {
            return void 0 === v1 && (v1 = new THREE.Vector3), this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)))
        }
    }(), angleTo: function (v) {
        var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
        return Math.acos(THREE.Math.clamp(theta, -1, 1))
    }, distanceTo: function (v) {
        return Math.sqrt(this.distanceToSquared(v))
    }, distanceToSquared: function (v) {
        var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz
    }, distanceToManhattan: function (v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z)
    }, setFromSpherical: function (s) {
        var sinPhiRadius = Math.sin(s.phi) * s.radius;
        return this.x = sinPhiRadius * Math.sin(s.theta), this.y = Math.cos(s.phi) * s.radius, this.z = sinPhiRadius * Math.cos(s.theta), this
    }, setFromMatrixPosition: function (m) {
        return this.setFromMatrixColumn(m, 3)
    }, setFromMatrixScale: function (m) {
        var sx = this.setFromMatrixColumn(m, 0).length(), sy = this.setFromMatrixColumn(m, 1).length(),
            sz = this.setFromMatrixColumn(m, 2).length();
        return this.x = sx, this.y = sy, this.z = sz, this
    }, setFromMatrixColumn: function (m, index) {
        if ("number" == typeof m) {
            console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).");
            var temp = m;
            m = index, index = temp
        }
        return this.fromArray(m.elements, 4 * index)
    }, equals: function (v) {
        return v.x === this.x && v.y === this.y && v.z === this.z
    }, fromArray: function (array, offset) {
        return void 0 === offset && (offset = 0), this.x = array[offset], this.y = array[offset + 1], this.z = array[offset + 2], this
    }, toArray: function (array, offset) {
        return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this.x, array[offset + 1] = this.y, array[offset + 2] = this.z, array
    }, fromAttribute: function (attribute, index, offset) {
        return void 0 === offset && (offset = 0), index = index * attribute.itemSize + offset, this.x = attribute.array[index], this.y = attribute.array[index + 1], this.z = attribute.array[index + 2], this
    }
}, THREE.Vector4 = function (x, y, z, w) {
    this.x = x || 0, this.y = y || 0, this.z = z || 0, this.w = void 0 !== w ? w : 1
}, THREE.Vector4.prototype = {
    constructor: THREE.Vector4, set: function (x, y, z, w) {
        return this.x = x, this.y = y, this.z = z, this.w = w, this
    }, setScalar: function (scalar) {
        return this.x = scalar, this.y = scalar, this.z = scalar, this.w = scalar, this
    }, setX: function (x) {
        return this.x = x, this
    }, setY: function (y) {
        return this.y = y, this
    }, setZ: function (z) {
        return this.z = z, this
    }, setW: function (w) {
        return this.w = w, this
    }, setComponent: function (index, value) {
        switch (index) {
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            case 3:
                this.w = value;
                break;
            default:
